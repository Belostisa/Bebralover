<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bebra</title>
  <link rel="icon" href="apple.svg" type="image/svg+xml">

  <link rel="stylesheet" href="style.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>

  <!-- FULL BACKGROUND VIDEO -->
  <div class="bg-video">
    <video autoplay muted loop playsinline>
      <source src="media/bg.mp4" type="video/mp4">
    </video>
  </div>

  <!-- AUDIO (loop is fine; we will handle end/stop too) -->
  <audio id="bgAudio" loop preload="auto" crossorigin="anonymous">
    <source src="media/sextape.mp3" type="audio/mpeg">
  </audio>

  <!-- FLOWERS -->
  <section class="flowers-section">
    <video autoplay muted loop playsinline class="flowers-video">
      <source src="media/flowers2.mp4" type="video/mp4">
    </video>
  </section>

  <!-- WAVE OVERLAY -->
  <div class="wave-overlay" id="waveOverlay" aria-hidden="true">
    <canvas id="waveCanvas"></canvas>
  </div>

  <!-- SINGLE PLAY BUTTON -->
  <button class="wave-play" id="playWave" aria-label="Play">‚ñ∂</button>

  <!-- ENVELOPE -->
  <section class="envelope-section">
    <div class="envelope" onclick="openEmail()">
      <div class="envelope-back"></div>
      <div class="inbox-label">INBOX</div>
      <div class="envelope-flap"></div>
    </div>
  </section>
  
  <!-- PASSWORD WINDOW -->
<div class="pass-overlay" id="passOverlay">
  <div class="pass-window" id="passWindow">
    <div class="email-header">
  <span class="email-title">
    <span class="lock-icon" id="lockIcon" aria-hidden="true">üîí</span>
    Locked
  </span>
  <button class="email-close" onclick="closePass()">‚úï</button>
</div>

    <div class="pass-body">
      <div class="pass-label">Enter password</div>

      <input
        id="passInput"
        class="pass-input"
        type="password"
        inputmode="numeric"
        autocomplete="one-time-code"
        placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
        maxlength="6"
      />

      <div class="pass-error" id="passError" aria-live="polite"></div>
    </div>

    <div class="email-footer">
      <button onclick="submitPass()">Unlock</button>
      <span id="passHint" style="justify-self:center; color:#9AFF7A; font-size:13px; letter-spacing:1px;">
        Protected
      </span>
      <button onclick="closePass()">Cancel</button>
    </div>
  </div>
</div>


  <!-- EMAIL WINDOW -->
  <div class="email-overlay" id="emailOverlay">
    <div class="email-window">
      <div class="email-header">
        <span class="email-title">Inbox</span>
        <button class="email-close" onclick="closeEmail()">‚úï</button>
      </div>

      <div class="email-body" id="emailContent"></div>

      <div class="email-footer">
        <button onclick="prevPage()">‚óÄ Prev</button>
        <span id="pageIndicator">1 / 3</span>
        <button onclick="nextPage()">Next ‚ñ∂</button>
      </div>
    </div>
  </div>

<script>
/* ============================================================
   PERFORMANCE PATCHES INCLUDED
   ‚úÖ Cap DPR for canvases (huge mobile win)
   ‚úÖ FX loop sleeps when no particles (no constant 60fps clears)
   ‚úÖ MAX_PARTICLES cap + click spam control (fixes lag on flower spam)
   ‚úÖ Smaller analyser FFT + fewer wave points
   ‚úÖ Stop waves + show play button when audio ends / pauses
   ‚úÖ Keeps typewriter + cache + autoscroll + envelope delay
============================================================ */

/* =========================
   EMAIL PAGES
========================= */
const pages = [
`–í—ã –ø–æ–º–Ω–∏—Ç–µ,
–í—ã –≤—Å—ë, –∫–æ–Ω–µ—á–Ω–æ, –ø–æ–º–Ω–∏—Ç–µ,
–ö–∞–∫ —è —Å—Ç–æ—è–ª,
–ü—Ä–∏–±–ª–∏–∑–∏–≤—à–∏—Å—å –∫ —Å—Ç–µ–Ω–µ,
–í–∑–≤–æ–ª–Ω–æ–≤–∞–Ω–Ω–æ —Ö–æ–¥–∏–ª–∏ –≤—ã –ø–æ –∫–æ–º–Ω–∞—Ç–µ
–ò —á—Ç–æ-—Ç–æ —Ä–µ–∑–∫–æ–µ
–í –ª–∏—Ü–æ –±—Ä–æ—Å–∞–ª–∏ –º–Ω–µ.

–í—ã –≥–æ–≤–æ—Ä–∏–ª–∏:
–ù–∞–º –ø–æ—Ä–∞ —Ä–∞—Å—Å—Ç–∞—Ç—å—Å—è,
–ß—Ç–æ –≤–∞—Å –∏–∑–º—É—á–∏–ª–∞
–ú–æ—è —à–∞–ª—å–Ω–∞—è –∂–∏–∑–Ω—å,
–ß—Ç–æ –≤–∞–º –ø–æ—Ä–∞ –∑–∞ –¥–µ–ª–æ –ø—Ä–∏–Ω–∏–º–∞—Ç—å—Å—è,
–ê –º–æ–π —É–¥–µ–ª ‚Äî
–ö–∞—Ç–∏—Ç—å—Å—è –¥–∞–ª—å—à–µ, –≤–Ω–∏–∑.
`,
`–ù–æ –≤—ã –Ω–µ –∑–Ω–∞–ª–∏,
–ß—Ç–æ –≤ —Å–ø–ª–æ—à–Ω–æ–º –¥—ã–º—É,
–í —Ä–∞–∑–≤–æ—Ä–æ—á–µ–Ω–Ω–æ–º –±—É—Ä–µ–π –±—ã—Ç–µ
–° —Ç–æ–≥–æ –∏ –º—É—á–∞—é—Å—å,
–ß—Ç–æ –Ω–µ –ø–æ–π–º—É,
–ö—É–¥–∞ –Ω–µ—Å–µ—Ç –Ω–∞—Å —Ä–æ–∫ —Å–æ–±—ã—Ç–∏–π‚Ä¶

–õ—é–±–∏–º–∞—è!
–°–∫–∞–∑–∞—Ç—å –ø—Ä–∏—è—Ç–Ω–æ –º–Ω–µ:
–Ø –∏–∑–±–µ–∂–∞–ª –ø–∞–¥–µ–Ω—å—è —Å –∫—Ä—É—á–∏.
–¢–µ–ø–µ—Ä—å –≤ –ü–∏–Ω–¥–æ—Å—Å–∫–æ–π —Å—Ç–æ—Ä–æ–Ω–µ
–Ø —Å–∞–º—ã–π —è—Ä–æ—Å—Ç–Ω—ã–π –ø–æ–ø—É—Ç—á–∏–∫.
`,
`–ü—Ä–æ—Å—Ç–∏—Ç–µ –º–Ω–µ‚Ä¶
–Ø –∑–Ω–∞—é: –≤—ã –Ω–µ —Ç–∞ ‚Äî
–ñ–∏–≤–µ—Ç–µ –≤—ã
–° —Å–µ—Ä—å–µ–∑–Ω—ã–º, —É–º–Ω—ã–º –º—É–∂–µ–º;
–ß—Ç–æ –Ω–µ –Ω—É–∂–Ω–∞ –≤–∞–º –Ω–∞—à–∞ –º–∞–µ—Ç–∞,
–ò —Å–∞–º —è –≤–∞–º
–ù–∏ –∫–∞–ø–µ–ª—å–∫–∏ –Ω–µ –Ω—É–∂–µ–Ω.

–ñ–∏–≤–∏—Ç–µ —Ç–∞–∫,
–ö–∞–∫ –≤–∞—Å –≤–µ–¥–µ—Ç –∑–≤–µ–∑–¥–∞,
–ï–±–∏—Ç–µ –±–∞–± –Ω–∞ —Å–≤–µ–∂–µ–º —Å–µ–Ω–µ.
–° –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ–º,
–í–∞—Å –ø–æ–º–Ω—è—â–∏–π –≤—Å–µ–≥–¥–∞
–ó–Ω–∞–∫–æ–º—ã–π –≤–∞—à
–°–µ—Ä–≥–µ–π –ï—Å–µ–Ω–∏–Ω.`
];

let currentPage = 0;

/* =========================
   TYPEWRITER REVEAL
========================= */
const emailBody = document.getElementById("emailContent");
let typingTimer = 0;
let typingToken = 0;
const typedCache = new Map();

// cursor CSS once
(function addCursorCSS(){
  if (document.getElementById("twCursorCSS")) return;
  const s = document.createElement("style");
  s.id = "twCursorCSS";
  s.textContent = `
    .tw-cursor{
      display:inline-block;
      width:0.7ch;
      margin-left:0.15ch;
      color:#9AFF7A;
      opacity:1;
      animation: twBlink 1.05s steps(1,end) infinite;
    }
    @keyframes twBlink { 0%,49%{opacity:1} 50%,100%{opacity:0} }
  `;
  document.head.appendChild(s);
})();

function stopTyping(){
  typingToken++;
  clearTimeout(typingTimer);
}

function autoScrollToCursor(){
  emailBody.scrollTop = emailBody.scrollHeight;
}

function getDelayForChar(ch, prevCh){
  let d = 52;
  if (ch === " ") d = 18;
  if (ch === ",") d = 170;
  if (ch === "." || ch === "!" || ch === "?") d = 340;
  if (prevCh === "\n" && ch === "\n") d = 1050;
  if (ch === "\n") d = 140;
  d += Math.random() * 22;
  return d;
}

function typewriterPage(pageIndex){
  stopTyping();
  const myToken = ++typingToken;

  const fullText = pages[pageIndex];
  const cached = typedCache.get(pageIndex);

  if (cached?.done){
    emailBody.textContent = fullText;
    document.getElementById("pageIndicator").textContent = `${pageIndex + 1} / ${pages.length}`;
    emailBody.scrollTop = 0;
    return;
  }

  let i = cached?.i ?? 0;
  let typedText = cached?.text ?? "";

  emailBody.textContent = typedText;

  const cursor = document.createElement("span");
  cursor.className = "tw-cursor";
  cursor.textContent = "‚ñã";
  emailBody.appendChild(cursor);

  document.getElementById("pageIndicator").textContent = `${pageIndex + 1} / ${pages.length}`;
  emailBody.scrollTop = 0;

  let last = (typedText.length ? typedText[typedText.length - 1] : "");

  const step = () => {
    if (myToken !== typingToken) return;

    if (i >= fullText.length){
      typedCache.set(pageIndex, { i: fullText.length, text: fullText, done: true });
      typingTimer = setTimeout(() => {
        if (cursor.parentNode) cursor.remove();
        autoScrollToCursor();
      }, 250);
      return;
    }

    const burst = (Math.random() < 0.08) ? 2 : 1;
    let chunk = "";

    for (let k = 0; k < burst && i < fullText.length; k++){
      const ch = fullText[i];
      cursor.insertAdjacentText("beforebegin", ch);
      chunk += ch;
      last = ch;
      i++;
    }

    typedText += chunk;
    typedCache.set(pageIndex, { i, text: typedText, done: false });

    autoScrollToCursor();

    const nextCh = fullText[i] || "";
    const delay = getDelayForChar(nextCh, last);
    typingTimer = setTimeout(step, delay);
  };

  step();
}

function renderPage(){ typewriterPage(currentPage); }

const PASSCODE = "081225";

let inboxUnlocked = localStorage.getItem("inboxUnlocked") === "1";

// ‚úÖ wrong-try counter (resets after success, and can reset when opening window too)
let passFails = 0;

const failMessages = [
  "–ù—é—Ö–∞–π –±–µ–±—Ä—É",
  "–†–∏–ª–∏ –Ω–µ–≥—Ä?",
  "–ü—Ä–∏–≤–µ—Ç, —Ä–æ–º–∞—à–∫–∏..."
];

function openEmail(){
  // show password modal first (not inbox)
  const env = document.querySelector(".envelope");
  env.classList.add("open");

  const DURATION_MS = 900;
  if (openEmail._pending) return;
  openEmail._pending = true;

  setTimeout(() => {
    openEmail._pending = false;
    openPass();
  }, DURATION_MS + 60);
}

function openPass(){
  const passOverlay = document.getElementById("passOverlay");
  const input = document.getElementById("passInput");
  const err = document.getElementById("passError");

  err.textContent = "";
  input.value = "";

  passOverlay.style.display = "flex";

  // focus after paint (mobile friendly)
  requestAnimationFrame(() => {
    input.focus();
  });
}

function closePass(){
  document.getElementById("passOverlay").style.display = "none";

  // if they cancel, close envelope too (optional but feels right)
  document.querySelector(".envelope").classList.remove("open");
}

function submitPass(){
  const input = document.getElementById("passInput");
  const err = document.getElementById("passError");

  const val = (input.value || "").trim();

 if (val !== PASSCODE){
  passFails++;

  err.textContent = passFails <= 3
    ? failMessages[passFails - 1]
    : "Wrong password";

  if (passFails >= 1){
    triggerGlitch();
  }

  input.focus();
  input.select?.();
  return;
}

 unlockSuccessAnim();

  // ‚úÖ correct
  inboxUnlocked = true;
  localStorage.setItem("inboxUnlocked", "1");

  passFails = 0;            // reset counter on success
  err.textContent = "";
  input.value = "";

  document.getElementById("passOverlay").style.display = "none";
  document.getElementById("emailOverlay").style.display = "flex";
  renderPage();
}

function triggerGlitch(){
  const win = document.getElementById("passWindow");
  const err = document.getElementById("passError");
  if (!win) return;

  win.classList.remove("glitch"); // restart
  void win.offsetWidth;           // force reflow
  win.classList.add("glitch");

  if (err){
    err.classList.add("glitch-text");
    setTimeout(() => err.classList.remove("glitch-text"), 420);
  }

  setTimeout(() => win.classList.remove("glitch"), 420);
}

function unlockSuccessAnim(){
  const icon = document.getElementById("lockIcon");
  if (!icon) return;

  // restart animation
  icon.classList.remove("unlock-ok");
  void icon.offsetWidth;
  icon.classList.add("unlock-ok");

  // swap icon to ‚Äúunlocked‚Äù briefly
  icon.textContent = "üîì";
}


// Enter key submits
document.addEventListener("keydown", (e) => {
  const passOverlay = document.getElementById("passOverlay");
  if (!passOverlay || passOverlay.style.display !== "flex") return;

  if (e.key === "Enter") submitPass();
  if (e.key === "Escape") closePass();
});

function closeEmail(){
  stopTyping();
  document.querySelector(".envelope").classList.remove("open");
  document.getElementById("emailOverlay").style.display = "none";
}

function nextPage(){
  if (currentPage < pages.length - 1){ currentPage++; renderPage(); }
}
function prevPage(){
  if (currentPage > 0){ currentPage--; renderPage(); }
}

/* =========================
   WAVES + PARTICLES
========================= */
const playBtn = document.getElementById("playWave");
const audioEl = document.getElementById("bgAudio");
const overlay = document.getElementById("waveOverlay");
const waveCanvas  = document.getElementById("waveCanvas");
const waveCtx     = waveCanvas.getContext("2d", { alpha: true });

const flowersSection = document.querySelector(".flowers-section");
const flowersVideo   = document.querySelector(".flowers-video");
const envelopeEl     = document.querySelector(".envelope");

let audioCtx = null;
let analyser = null;
let srcNode  = null;
let timeData = null;
let freqData = null;

let started = false;
let rafId = 0;
let posRaf = 0;

const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
const lerp  = (a, b, t) => a + (b - a) * t;

function waveThickness(){
  return window.matchMedia("(max-width: 600px)").matches ? 1.0 : 1.25;
}

/* =========================
   DPR CAP (BIG PERF WIN)
========================= */
function getDPR(){
  const isMobile = window.matchMedia("(max-width: 600px)").matches;
  return Math.min(isMobile ? 1.2 : 1.5, window.devicePixelRatio || 1);
}

/* =========================
   FULLSCREEN FX CANVAS
========================= */
const fxCanvas = document.createElement("canvas");
fxCanvas.id = "fxCanvas";
Object.assign(fxCanvas.style, {
  position: "fixed",
  inset: "0",
  width: "100vw",
  height: "100vh",
  zIndex: "5",
  pointerEvents: "none"
});
document.body.appendChild(fxCanvas);

const fxCtx = fxCanvas.getContext("2d", { alpha: true });

function resizeFxCanvas(){
  const dpr = getDPR();
  fxCanvas.width = Math.floor(innerWidth * dpr);
  fxCanvas.height = Math.floor(innerHeight * dpr);
  fxCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function resizeWaveCanvas(){
  const rect = waveCanvas.getBoundingClientRect();
  const dpr = getDPR();
  const w = Math.max(1, Math.floor(rect.width  * dpr));
  const h = Math.max(1, Math.floor(rect.height * dpr));
  if (waveCanvas.width !== w || waveCanvas.height !== h){
    waveCanvas.width = w;
    waveCanvas.height = h;
  }
  waveCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

/* =========================
   Place waves BETWEEN flowers + envelope
========================= */
function updateWavePosition(){
  if (!flowersSection || !envelopeEl) return;

  const f = flowersSection.getBoundingClientRect();
  const e = envelopeEl.getBoundingClientRect();

  let y = (f.bottom + e.top) / 2;
  y -= Math.min(28, innerHeight * 0.035);

  const overlayH = overlay?.getBoundingClientRect().height || 120;
  y -= overlayH / 2;

  const pad = Math.max(48, Math.min(96, innerHeight * 0.08));
  y = clamp(y, pad, innerHeight - pad);

  document.documentElement.style.setProperty("--wave-y", `${y}px`);
}

function scheduleLayoutUpdate(){
  if (posRaf) return;
  posRaf = requestAnimationFrame(() => {
    posRaf = 0;
    updateWavePosition();
    resizeWaveCanvas();
    resizeFxCanvas();
  });
}

window.addEventListener("resize", scheduleLayoutUpdate, { passive: true });
window.addEventListener("scroll", scheduleLayoutUpdate, { passive: true });

if (window.visualViewport){
  visualViewport.addEventListener("resize", scheduleLayoutUpdate, { passive: true });
  visualViewport.addEventListener("scroll", scheduleLayoutUpdate, { passive: true });
}

const ro = new ResizeObserver(() => scheduleLayoutUpdate());
if (flowersSection) ro.observe(flowersSection);
if (envelopeEl) ro.observe(envelopeEl);

scheduleLayoutUpdate();
setTimeout(scheduleLayoutUpdate, 150);
setTimeout(scheduleLayoutUpdate, 650);

/* =========================
   Audio analyser (lighter)
========================= */
function setupAnalyser(){
  if (audioCtx) return;

  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 1024;
  analyser.smoothingTimeConstant = 0.82;

  timeData = new Uint8Array(analyser.frequencyBinCount);
  freqData = new Uint8Array(analyser.frequencyBinCount);

  srcNode = audioCtx.createMediaElementSource(audioEl);
  srcNode.connect(analyser);
  analyser.connect(audioCtx.destination);
}

let rmsSmooth = 0;
let trebleSmooth = 0;

function readAudio(){
  analyser.getByteTimeDomainData(timeData);
  analyser.getByteFrequencyData(freqData);

  let sum = 0;
  for (let i = 0; i < timeData.length; i++){
    const v = (timeData[i] - 128) / 128;
    sum += v * v;
  }
  const rms = Math.sqrt(sum / timeData.length);
  rmsSmooth = lerp(rmsSmooth, rms, 0.09);

  let hi = 0;
  const start = Math.floor(freqData.length * 0.35);
  for (let i = start; i < freqData.length; i++) hi += freqData[i];
  const hiNorm = hi / ((freqData.length - start) * 255);
  trebleSmooth = lerp(trebleSmooth, clamp(hiNorm, 0, 1), 0.12);

  return { level: rmsSmooth, treble: trebleSmooth };
}

/* =========================
   Particles (FX loop sleeps + spam protection)
========================= */
const particles = [];
const MAX_PARTICLES = 220; // ‚úÖ hard cap (try 160‚Äì260)

function rand(a, b){ return a + Math.random() * (b - a); }

let fxRaf = 0;
function ensureFxLoop(){
  if (fxRaf) return;
  const tick = () => {
    if (particles.length === 0){
      fxRaf = 0;
      return;
    }
    drawParticles();
    fxRaf = requestAnimationFrame(tick);
  };
  fxRaf = requestAnimationFrame(tick);
}

function clampParticles(){
  while (particles.length > MAX_PARTICLES) particles.shift();
}

function spawnFlowerOrbs(vx, vy){
  const isMobile = window.matchMedia("(max-width: 600px)").matches;
  const count = isMobile ? 8 : 14; // ‚úÖ fewer on mobile

  for (let i = 0; i < count; i++){
    const angle = rand(-Math.PI * 0.80, -Math.PI * 0.20);
    const speed = rand(0.9, 2.4);
    particles.push({
      x: vx, y: vy,
      vx: Math.cos(angle) * speed + rand(-0.22, 0.22),
      vy: Math.sin(angle) * speed + rand(-0.16, 0.10),
      life: 1,
      r: rand(0.9, 1.7),
      w: rand(1.3, 2.6),
      ph: rand(0, Math.PI * 2),
      type: "orb"
    });
  }

  clampParticles();
  ensureFxLoop();
}

function spawnCyanBurst(vx, vy){
  const isMobile = window.matchMedia("(max-width: 600px)").matches;
  const count = isMobile ? 8 : 12;

  for (let i = 0; i < count; i++){
    const angle = rand(0, Math.PI * 2);
    const speed = rand(0.7, 1.8);
    particles.push({
      x: vx, y: vy,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 1,
      r: rand(1.6, 3.0),
      type: "cyan"
    });
  }

  clampParticles();
  ensureFxLoop();
}

function drawParticles(){
  if (particles.length === 0) return;

  fxCtx.clearRect(0, 0, innerWidth, innerHeight);

  for (let i = particles.length - 1; i >= 0; i--){
    const p = particles[i];

    p.x += p.vx;
    p.y += p.vy;

    p.vx *= 0.989;
    p.vy *= 0.988;
    p.vy -= (p.type === "orb" ? 0.0062 : 0.0028);

    if (p.type === "orb"){
      const t = performance.now() * 0.001;
      p.x += Math.sin(t * p.w + p.ph) * 0.26;
    }

    // ‚úÖ slightly shorter lifetime reduces ‚Äúpile-up‚Äù
    p.life -= (p.type === "orb" ? 0.012 : 0.016);

    if (p.life <= 0){
      particles.splice(i, 1);
      continue;
    }

    fxCtx.save();
    fxCtx.globalCompositeOperation = "lighter";
    fxCtx.globalAlpha = p.life;

    if (p.type === "cyan"){
      fxCtx.fillStyle = "rgba(120,255,255,0.66)";
      fxCtx.shadowColor = "rgba(120,255,255,0.30)";
      fxCtx.shadowBlur = 10;
      fxCtx.beginPath();
      fxCtx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      fxCtx.fill();
      fxCtx.restore();
      continue;
    }

    const core = p.r;
    const aura = p.r * 6.3;

    fxCtx.fillStyle = "rgba(255,140,210,0.10)";
    fxCtx.shadowColor = "rgba(255,140,210,0.22)";
    fxCtx.shadowBlur = 18;
    fxCtx.beginPath();
    fxCtx.arc(p.x, p.y, aura, 0, Math.PI * 2);
    fxCtx.fill();

    fxCtx.shadowBlur = 12;
    fxCtx.fillStyle = "rgba(255,195,235,0.42)";
    fxCtx.beginPath();
    fxCtx.arc(p.x, p.y, core, 0, Math.PI * 2);
    fxCtx.fill();

    fxCtx.restore();
  }
}

/* =========================
   FLOWER CLICK -> ORBS
   ‚úÖ dynamic cooldown when lots of particles exist
========================= */
let lastFlower = 0;

function pointInShrunkRect(x, y, r, shrinkX = 0.18, shrinkTop = 0.10, shrinkBottom = 0.22){
  const left   = r.left + r.width  * shrinkX;
  const right  = r.right - r.width * shrinkX;
  const top    = r.top + r.height  * shrinkTop;
  const bottom = r.bottom - r.height * shrinkBottom;
  return (x >= left && x <= right && y >= top && y <= bottom);
}

document.addEventListener("click", (e) => {
  if (!flowersVideo) return;
  if (e.target.closest(".envelope") || e.target.closest(".email-overlay")) return;

  const r = flowersVideo.getBoundingClientRect();
  const inside = pointInShrunkRect(e.clientX, e.clientY, r, 0.28, 0.16, 0.44);
  if (!inside) return;

  const now = Date.now();

  const extraDelay = particles.length > 140 ? 220 : 0;
  const minGap = 140 + extraDelay;

  if (now - lastFlower < minGap) return;
  lastFlower = now;

  spawnFlowerOrbs(e.clientX, e.clientY);
}, { passive: true });

/* =========================
   Play button show/hide logic
========================= */
function showPlayButton(){ playBtn.classList.remove("hidden"); }
function hidePlayButton(){ playBtn.classList.add("hidden"); }

function stopWaves(){
  started = false;
  overlay.classList.remove("active");

  const w = waveCanvas.clientWidth;
  const h = waveCanvas.clientHeight;
  waveCtx.clearRect(0, 0, w, h);
}

audioEl.addEventListener("ended", () => {
  stopWaves();
  showPlayButton();
});

audioEl.addEventListener("pause", () => {
  stopWaves();
  showPlayButton();
});

/* =========================
   Play button dissolve (particles a bit higher)
========================= */
function dissolvePlayButton(){
  const r = playBtn.getBoundingClientRect();
  const cx = r.left + r.width / 2;
  const cy = r.top + r.height / 2 - 28;
  spawnCyanBurst(cx, cy);
  hidePlayButton();
}

/* =========================
   Waves drawing
========================= */
function strokeNeonBlue(drawPath, thickness = 1, glow = 1){
  waveCtx.save();
  waveCtx.globalCompositeOperation = "lighter";
  waveCtx.lineCap = "round";

  waveCtx.shadowColor = "rgba(90,245,255,0.08)";
  waveCtx.shadowBlur  = 11 * glow;
  waveCtx.lineWidth   = 3.4 * thickness;
  waveCtx.strokeStyle = "rgba(90,245,255,0.07)";
  drawPath(); waveCtx.stroke();

  waveCtx.shadowColor = "rgba(90,245,255,0.20)";
  waveCtx.shadowBlur  = 6.5 * glow;
  waveCtx.lineWidth   = 2.1 * thickness;
  waveCtx.strokeStyle = "rgba(90,245,255,0.18)";
  drawPath(); waveCtx.stroke();

  waveCtx.shadowBlur  = 0;
  waveCtx.lineWidth   = 1.05 * thickness;
  waveCtx.strokeStyle = "rgba(120,255,255,0.82)";
  drawPath(); waveCtx.stroke();

  waveCtx.restore();
}

function envelopeShape(u){ return Math.pow(Math.sin(Math.PI * u), 1.45); }
function fbm(u, t, s = 1){
  return (
    Math.sin((u * 10.0 * s) + t * 1.3) * 0.55 +
    Math.sin((u * 23.0 * s) - t * 2.2) * 0.28 +
    Math.sin((u * 52.0 * s) + t * 3.7) * 0.17
  );
}
function travelingPulse(u, t, speed = 0.18, width = 0.06){
  const p = (t * speed) % 1;
  const d = Math.min(Math.abs(u - p), 1 - Math.abs(u - p));
  return Math.exp(-(d * d) / (width * width));
}

function startLoop(){
  if (rafId) return;

  const loop = (now) => {
    rafId = requestAnimationFrame(loop);
    if (!started) return;

    const { level, treble } = readAudio();

    const w = waveCanvas.clientWidth;
    const h = waveCanvas.clientHeight;
    waveCtx.clearRect(0, 0, w, h);

    const t = now / 1000;
    const thickMul = waveThickness();

    const baseAmp = 6;
    const maxAmp  = 90;
    const ampPx   = baseAmp + maxAmp * Math.pow(level, 0.80);

    const electric = 0.35 + 0.95 * treble;
    const centerY = h * 0.5;

    const points = Math.max(160, Math.floor(w / 5));
    const dx = w / (points - 1);

    waveCtx.save();
    waveCtx.globalCompositeOperation = "lighter";
    waveCtx.globalAlpha = 0.07 + 0.22 * level;
    waveCtx.fillStyle = "rgba(90,245,255,0.16)";
    waveCtx.fillRect(0, centerY - 1, w, 2);
    waveCtx.restore();

    const disp = new Array(points);
    for (let i = 0; i < points; i++){
      const u = i / (points - 1);
      const idx = Math.floor(u * (timeData.length - 1));
      const a = (timeData[idx] - 128) / 128;

      const pulse1 = travelingPulse(u, t, 0.20, 0.055);
      const pulse2 = travelingPulse(u, t + 2.1, 0.14, 0.08);

      const wobble = fbm(u, t * electric, 1.0) * 0.55;
      const micro  = Math.sin(t * (12.0 * electric) + u * (140 * electric)) * 0.12;

      const env = envelopeShape(u);

      disp[i] =
        env * (
          ampPx * (a * (0.62 + 0.55 * level)) +
          (18 + 38 * level) * wobble +
          (10 + 30 * treble) * micro +
          (55 * pulse1 * (0.20 + level)) +
          (32 * pulse2 * (0.15 + level * 0.8))
        );
    }

    function lensPair(phase, alpha, thickness, glow){
      waveCtx.save();
      waveCtx.globalAlpha = alpha;

      const phaseWarp = (u) =>
        Math.sin(u * 14 + t * (1.1 + phase)) * (1.5 + 3.0 * treble);

      const upperPath = () => {
        waveCtx.beginPath();
        for (let i = 0; i < points; i++){
          const u = i / (points - 1);
          const x = i * dx;
          const y = centerY - (disp[i] + phaseWarp(u));
          if (i === 0) waveCtx.moveTo(x, y);
          else waveCtx.lineTo(x, y);
        }
      };

      const lowerPath = () => {
        waveCtx.beginPath();
        for (let i = 0; i < points; i++){
          const u = i / (points - 1);
          const x = i * dx;
          const y = centerY + (disp[i] - phaseWarp(u) * 0.6);
          if (i === 0) waveCtx.moveTo(x, y);
          else waveCtx.lineTo(x, y);
        }
      };

      const glowBoost = 0.72 + 0.85 * level + 0.55 * treble;

      strokeNeonBlue(upperPath, thickness * thickMul, glowBoost * glow);
      strokeNeonBlue(lowerPath, thickness * thickMul, glowBoost * glow);

      waveCtx.restore();
    }

    lensPair(0.0, 0.90, 1.08, 1.0);
    lensPair(1.1, 0.55, 0.95, 0.85);
    lensPair(2.2, 0.35, 0.82, 0.75);
  };

  rafId = requestAnimationFrame(loop);
}

/* =========================
   Play click (starts waves + audio)
========================= */
playBtn.addEventListener("click", async (e) => {
  e.preventDefault();
  e.stopPropagation();

  setupAnalyser();
  if (audioCtx.state === "suspended") await audioCtx.resume();

  audioEl.muted = false;
  audioEl.volume = 0.35;

  if (audioEl.paused) await audioEl.play();

  started = true;
  overlay.classList.add("active");

  dissolvePlayButton();

  scheduleLayoutUpdate();
  startLoop();
});

/* =========================
   Pause heavy work when tab hidden
========================= */
document.addEventListener("visibilitychange", () => {
  if (document.hidden){
    stopWaves();
    if (fxRaf){ cancelAnimationFrame(fxRaf); fxRaf = 0; }
  } else {
    if (!audioEl.paused) {
      started = true;
      overlay.classList.add("active");
    }
    if (particles.length) ensureFxLoop();
  }
});
</script>

<!-- CRT overlay stays as-is; your CSS controls intensity/curvature -->
<div class="crt-wrap" aria-hidden="true">
  <div class="crt"></div>
</div>

</body>
</html>










